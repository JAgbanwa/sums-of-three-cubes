from sage.all import *
import time
import resource

def unlimited_rational_points_search():
    """
    ABSOLUTELY UNLIMITED search for rational points on:
    y² = x³ - 912x - 1681559
    Pushing SageMath to its absolute computational limits
    """
    print("UNLIMITED RATIONAL POINTS SEARCH")
    print("=" * 80)
    print("Curve: y² = x³ - 912x - 1681559")
    print("=" * 80)
    
    # Define the elliptic curve
    E = EllipticCurve([-912, -1681559])
    print(f"Elliptic Curve: {E}")
    print(f"Discriminant: {E.discriminant()}")
    print()
    
    # Start timing and memory monitoring
    start_time = time.time()
    
    # 1. MAXIMUM EFFORT MORDELL-WEIL GROUP COMPUTATION
    print("1. MAXIMUM EFFORT GROUP STRUCTURE COMPUTATION")
    print("-" * 60)
    
    all_points = set()
    
    # Torsion with maximum effort
    print("Computing torsion subgroup...")
    try:
        torsion_group = E.torsion_subgroup()
        torsion_points = E.torsion_points()
        print(f"Torsion: {torsion_group}")
        all_points.update(torsion_points)
        for pt in torsion_points:
            if pt != E(0,1,0):
                x, y = pt.xy()
                print(f"  ({x}, {y})")
    except Exception as e:
        print(f"Torsion failed: {e}")
    
    # Rank with every possible method
    print("\nComputing rank with all algorithms...")
    rank_methods = [
        ('Default', lambda: E.rank()),
        ('Proof=False', lambda: E.rank(proof=False)),
        ('mwrank only', lambda: E.rank(algorithm='mwrank')),
        ('pari only', lambda: E.rank(algorithm='pari')),
    ]
    
    rank = None
    for method_name, method in rank_methods:
        try:
            r = method()
            print(f"  {method_name}: rank = {r}")
            if rank is None:
                rank = r
        except Exception as e:
            print(f"  {method_name}: failed - {e}")
    
    # 2. EXTREME GENERATOR SEARCH
    print("\n2. EXTREME GENERATOR SEARCH")
    print("-" * 60)
    
    generators = []
    try:
        print("Searching for generators with maximum effort...")
        generators = E.gens(proof=False, algorithm='all')
        print(f"Found {len(generators)} generators")
        for i, gen in enumerate(generators):
            x, y = gen.xy()
            height_val = gen.height()
            print(f"  Generator {i+1}:")
            print(f"    ({x}, {y})")
            print(f"    Height: {height_val}")
            all_points.add(gen)
            all_points.add(-gen)
    except Exception as e:
        print(f"Generator search failed: {e}")
    
    # 3. MASSIVE INTEGRAL POINTS SEARCH
    print("\n3. MASSIVE INTEGRAL POINTS SEARCH")
    print("-" * 60)
    
    try:
        print("Computing all integral points...")
        integral_points = E.integral_points()
        print(f"Found {len(integral_points)} integral points")
        for pt in integral_points:
            x, y = pt.xy()
            print(f"  ({x}, {y})")
            all_points.add(pt)
            all_points.add(-pt)
    except Exception as e:
        print(f"Integral points failed: {e}")
    
    # 4. UNLIMITED RATIONAL POINT SEARCH
    print("\n4. UNLIMITED RATIONAL POINT SEARCH")
    print("-" * 60)
    
    def unlimited_rational_search():
        """Search until we run out of memory or user interrupts"""
        found_points = set()
        max_denom = 1
        max_iterations = 1000  # Safety limit, but we'll keep increasing bounds
        
        print("Starting unlimited rational point search...")
        print("This will continue until memory is exhausted or search is interrupted")
        print("Increasing denominator bounds exponentially...")
        
        for iteration in range(max_iterations):
            current_time = time.time() - start_time
            mem_usage = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024 / 1024
            
            print(f"\nIteration {iteration + 1}:")
            print(f"  Time: {current_time:.1f}s, Memory: {mem_usage:.1f}MB")
            print(f"  Searching denominators 1 to {max_denom}...")
            
            new_points = 0
            total_checked = 0
            
            for denom in range(1, max_denom + 1):
                if denom % max(1, max_denom // 10) == 0:
                    print(f"    Progress: {denom}/{max_denom} denominators")
                
                for num in range(-max_denom * 100, max_denom * 100 + 1):
                    total_checked += 1
                    if total_checked % 1000000 == 0:
                        current_mem = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024 / 1024
                        print(f"      Checked {total_checked} x values, Memory: {current_mem:.1f}MB")
                    
                    if gcd(num, denom) != 1:
                        continue
                    
                    try:
                        x = QQ(num) / QQ(denom)
                        rhs = x**3 - 912*x - 1681559
                        
                        if rhs >= 0:
                            # Check if perfect square
                            if rhs.is_square():
                                y = sqrt(rhs)
                                if y in QQ:
                                    try:
                                        point = E(x, y)
                                        if point not in found_points:
                                            found_points.add(point)
                                            found_points.add(-point)
                                            new_points += 1
                                            x_val, y_val = point.xy()
                                            print(f"    NEW POINT: ({x_val}, {y_val})")
                                    except:
                                        pass
                    except MemoryError:
                        print("MEMORY LIMIT REACHED!")
                        return found_points
                    except KeyboardInterrupt:
                        print("SEARCH INTERRUPTED BY USER")
                        return found_points
                    except:
                        pass
            
            print(f"  Found {new_points} new points in this iteration")
            
            # Exponentially increase search range
            old_denom = max_denom
            max_denom = min(max_denom * 4, 10**9)  # Cap at 1 billion to prevent insanity
            
            if new_points == 0 and max_denom > 10**6:
                print("  No new points found at large bounds, stopping search")
                break
            
            if max_denom == 10**9:
                print("  Reached maximum denominator bound of 1 billion")
                break
        
        return found_points
    
    try:
        rational_points = unlimited_rational_search()
        print(f"\nUnlimited search found {len(rational_points)} rational points")
        all_points.update(rational_points)
    except Exception as e:
        print(f"Unlimited search failed: {e}")
    
    # 5. EXTREME GENERATOR MULTIPLICATION
    print("\n5. EXTREME GENERATOR MULTIPLICATION")
    print("-" * 60)
    
    if generators:
        print("Generating extreme multiples of generators...")
        for i, gen in enumerate(generators):
            print(f"Generator {i+1}:")
            max_multiple = 1000  # Try up to 1000P
            
            for n in range(1, max_multiple + 1):
                try:
                    if n % 100 == 0:
                        print(f"  Computing {n}P...")
                    
                    nP = n * gen
                    all_points.add(nP)
                    all_points.add(-nP)
                    
                    if n in [1, 2, 5, 10, 50, 100, 500, 1000]:
                        x, y = nP.xy()
                        print(f"    {n}P = ({x}, {y})")
                        
                except MemoryError:
                    print(f"  Memory limit reached at {n}P")
                    break
                except KeyboardInterrupt:
                    print(f"  Interrupted at {n}P")
                    break
                except:
                    pass
    
    # 6. MAXIMUM DATABASE INTEGRATION
    print("\n6. MAXIMUM DATABASE INTEGRATION")
    print("-" * 60)
    
    databases = [
        ("LMFDB", lambda: E.lmfdb_label()),
        ("Cremona", lambda: E.cremona_label()),
    ]
    
    for db_name, db_func in databases:
        try:
            label = db_func()
            print(f"{db_name}: {label}")
            
            if db_name == "LMFDB":
                try:
                    E_db = EllipticCurve(label)
                    db_points = E_db.gens()
                    if db_points:
                        print(f"  {db_name} generators: {len(db_points)}")
                        for pt in db_points:
                            all_points.add(pt)
                            all_points.add(-pt)
                except:
                    pass
        except Exception as e:
            print(f"{db_name}: {e}")
    
    # 7. ADVANCED ALGORITHMS
    print("\n7. ADVANCED ALGORITHMS")
    print("-" * 60)
    
    # Two-descent with maximum search
    try:
        print("Running two-descent with maximum search limits...")
        two_descent = E.two_descent(verbose=False)
        selmer_rank = E.selmer_rank()
        print(f"Selmer rank: {selmer_rank}")
    except Exception as e:
        print(f"Two-descent failed: {e}")
    
    # Heegner point method
    print("\nTrying Heegner point method...")
    cm_discriminants = [-3, -4, -7, -8, -11, -19, -20, -24, -35, -40, -43, -51, -52, -67, -88, -91, -115, -123, -148, -163, -187, -232, -235, -267, -403, -427]
    
    for D in cm_discriminants:
        try:
            heegner_pt = E.heegner_point(D)
            if heegner_pt != E(0):
                x, y = heegner_pt.xy()
                print(f"  Heegner point for D={D}: ({x}, {y})")
                all_points.add(heegner_pt)
                all_points.add(-heegner_pt)
        except:
            pass
    
    # 8. FINAL RESULTS
    print("\n8. FINAL RESULTS")
    print("-" * 60)
    
    # Remove duplicates and sort
    final_points = sorted(all_points, key=lambda pt: pt.height() if pt != E(0,1,0) else -1)
    
    total_time = time.time() - start_time
    final_memory = resource.getrusage(resource.RUSAGE_SELF).ru_maxrss / 1024 / 1024
    
    print(f"SEARCH COMPLETED IN {total_time:.1f} SECONDS")
    print(f"MAXIMUM MEMORY USED: {final_memory:.1f} MB")
    print(f"TOTAL POINTS FOUND: {len(final_points)}")
    
    # Analysis
    torsion_count = len([pt for pt in final_points if pt.order() != float('inf')])
    infinite_count = len([pt for pt in final_points if pt.order() == float('inf')])
    
    print(f"\nPOINT ANALYSIS:")
    print(f"  Point at infinity: 1")
    print(f"  Torsion points: {torsion_count}")
    print(f"  Points of infinite order: {infinite_count}")
    
    if rank is not None:
        print(f"  Rank: {rank}")
    
    # Display points
    print(f"\nALL RATIONAL POINTS FOUND (first 100):")
    count = 0
    for pt in final_points:
        if pt != E(0,1,0) and count < 100:
            x, y = pt.xy()
            print(f"  ({x}, {y})")
            count += 1
    
    if len(final_points) > 100:
        non_infinite = len([p for p in final_points if p != E(0,1,0)])
        print(f"  ... and {non_infinite - 100} more points")
    
    return E, final_points, rank, generators

# Main execution with ultimate error handling
if __name__ == "__main__":
    print("ULTIMATE UNLIMITED RATIONAL POINTS SEARCH")
    print("Curve: y² = x³ - 912x - 1681559")
    print("NO LIMITS - WILL SEARCH UNTIL COMPUTATIONAL BOUNDARIES")
    print()
    
    try:
        E, all_points, rank, generators = unlimited_rational_points_search()
        
        print("\n" + "=" * 80)
        print("ULTIMATE SEARCH COMPLETE!")
        print("=" * 80)
        print(f"FINAL COUNT: {len(all_points)} rational points found")
        
        if rank == 0:
            print("RANK 0 - All rational points have been found!")
        elif rank and rank > 0:
            print(f"RANK {rank} - Found generators and representative points")
            print("There are infinitely many rational points")
        
        print("\nThis represents the ABSOLUTE MAXIMUM that can be computed")
        print("with current computational resources and algorithms!")
        
    except MemoryError as e:
        print("\n" + "=" * 80)
        print("COMPUTATIONAL BOUNDARY REACHED!")
        print("=" * 80)
        print("SageMath exhausted all available memory")
        print("This is the absolute limit of what can be computed")
        print(f"Error: {e}")
        
    except KeyboardInterrupt:
        print("\n" + "=" * 80)
        print("SEARCH MANUALLY STOPPED")
        print("=" * 80)
        print("User interrupted the unlimited search")
        print("Results up to interruption have been saved")
        
    except Exception as e:
        print("\n" + "=" * 80)
        print("UNEXPECTED ERROR")
        print("=" * 80)
        print(f"Search failed with error: {e}")
        print("This curve may be computationally intractable")
